# Discusssed with Cameron Willette.
# Dinic's algorithm implementation from Piazza
from collections import deque

MAX = 10**18

class Edge:
    """
    A helper class for Dinic's algorithm. There is no need to modify this class unless you really want to.
    """
    start: int
    end: int
    capacity: int
    flow: int = 0

    def __init__(self, start: int, end: int, capacity: int):
        self.start, self.end, self.capacity = start, end, capacity


class Dinic:
    """
    Peforms Dinic's algorithm
    """
    # a list of edges in the graph
    edges: list[Edge]
    # an adjacency list; note that it stores the index of an edge in the edges list, not the id of a neighboring vertex
    adj: list[list[int]]
    # stores the level of each vertex; generated by BFS
    levels: list[int]
    # for each vertex, store the index (in the adjacency list) of the edge we should visit next;
    # any edge with a smaller index is marked as dead
    current_edge: list[int]

    # number of vertices in the graph
    n: int
    source: int
    sink: int
    # number of edges in the graph
    edge_counter: int = 0

    def __init__(self, n: int, s: int, t: int):
        """
        :param n: number of vertices (they will be indexed from 0 to n - 1)
        :param s: source of flow problem
        :param t: sink of flow problem
        """
        self.n = n
        self.source = s
        self.sink = t
        self.adj = [list() for _ in range(n)]
        self.edges = []

    def add_edge(self, u: int, v: int, capacity: int) -> None:
        """
        Adds an edge to the graph between vertex u and vertex v with a designated capacity.
        """
        self.edges.append(Edge(u, v, capacity))
        self.edges.append(Edge(v, u, 0))
        self.adj[u].append(self.edge_counter)
        self.edge_counter+=1
        self.adj[v].append(self.edge_counter)
        self.edge_counter+=1


    def __bfs(self) -> bool:
        """
        Internal function of Dinic's algorithm. Should not be invoked directly in your solution (or maybe you can
        take advantage of this function somehow?).

        Finds the level of each vertex.

        :return: whether it is possible to find an augmenting path
        """
        self.levels = [-1 for _ in range(self.n)]
        self.levels[self.source] = 0
        queue = deque()
        queue.append(self.source)

        while (len(queue) > 0):
            u = queue.popleft()
            for edge_id in self.adj[u]:
                e = self.edges[edge_id]

                if e.capacity - e.flow <= 0 or self.levels[e.end] != -1:
                    continue

                self.levels[e.end] = self.levels[u] + 1
                queue.append(e.end)

        return self.levels[self.sink] != -1

    def __dfs(self, u: int, current_flow: int) -> int:
        """
        Internal function of Dinic's algorithm. Should not be invoked directly in your solution.

        Performs DFS to find an augmenting path and mark other edges as dead.

        :param u: current vertex in the DFS traversal
        :param current_flow: the amount of flow that can be sent from the source to u in the current path
        :return: the flow achieved by the discovered augmenting path; 0 if we run into a dead end
        """
        if current_flow == 0:
            return 0
        if u == self.sink:
            return current_flow

        # start traversal from the first non-dead edge
        for i in range(self.current_edge[u], len(self.adj[u])):
            self.current_edge[u] = i
            edge = self.edges[self.adj[u][i]]
            if self.levels[edge.end] != self.levels[u] + 1 or edge.capacity - edge.flow <= 0:
                continue

            f = self.__dfs(edge.end, min(current_flow, edge.capacity - edge.flow))

            if f == 0:
                continue

            self.edges[self.adj[u][i]].flow += f
            # flip the parity of self.adj[u][i]
            self.edges[self.adj[u][i] ^ 1].flow -= f
            return f
        return 0

    def get_flow(self) -> int:
        """
        Compute the amount of flow that can go through the flow network.
        """
        answer = 0

        while True:
            if self.__bfs() == 0:
                break

            self.current_edge = [0 for _ in range(self.n)]

            while True:
                flow = self.__dfs(self.source, MAX)
                if flow == 0:
                    break
                answer += flow
        return answer

    def get_source_set(self) -> list[int]:
        """
        Retrieves a list of vertices that are connected to the source after applying min-cut. You can implement this function if you need it.
        The presence of this function might tell you something about the intended solution to this problem.

        Normally, you will need about 15 lines of code for this function, but a realization will allow you to accomplish the same task in two lines.

        :return: a list of vertices connected to the source after min-cut; note that you can either choose to include
        or exclude the source based on your preferences
        """
        source_set = []
        q = deque([self.source])
        visited = set()
        visited.add(self.source)

        while q:
            u = q.popleft()
            for id in self.adj[u]:
                e = self.edges[id]
                if (not (e.end in visited)) and (e.capacity - e.flow > 0):
                    visited.add(e.end)
                    q.append(e.end)
                    if (e.end != self.sink and e.end != self.source):
                        source_set.append(e.end)
        return source_set

def ub_gen(l):
    total = 0
    for item in l:
        if (item > 0):
            total += item
    return total

def main():
    num_balls, num_rules = map(int, input().split())
    ball_values = list(map(int, input().split()))
    rules = []
    for i in range(num_rules):
        rules.append(tuple(map(int, input().split())))
    s = 0
    t = num_balls + 1
    fn = Dinic(num_balls + 2, s, t)
    ub = ub_gen(ball_values)
    for i, ball_value in enumerate(ball_values, start=1):
        if ball_value > 0:
            fn.add_edge(s, i, ball_value)
        elif ball_value < 0:
            fn.add_edge(i, t, -ball_value)

    for rule in rules:
        if (rule[0] == 1):
            fn.add_edge(rule[1], rule[2], rule[3])
        elif (rule[0] == 2):
            fn.add_edge(rule[1], rule[2], MAX)
    min_cut = fn.get_flow()
    max_prize = max(0, ub - min_cut)
    print(max_prize)
    s_set = fn.get_source_set()
    print(len(s_set))

    for v in s_set:
        print(v, end=' ')
main()